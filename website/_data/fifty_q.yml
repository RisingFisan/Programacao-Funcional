1:
  function: enumFromTo
  description: "Apresente uma definição recursiva da função (pré-definida) `enumFromTo :: Int -> Int -> [Int]` que constrói a lista dos números inteiros compreendidos entre dois limites."
2:
  function: enumFromThenTo
  description: "Apresente uma definição recursiva da função (pré-definida) `enumFromThenTo :: Int -> Int -> Int -> [Int]` que constrói a lista dos números inteiros compreendidos entre dois limites e espaçados de um valor constante."
3:
  function: (++)
  description: "Apresente uma definição recursiva da função (pré-definida) `(++) :: [a] -> [a] -> [a]` que concatena duas listas."
4:
  function: (!!)
  description: "Apresente uma definição recursiva da função (pré-definida) `(!!) :: [a] -> Int -> a` que dada uma lista e um inteiro, calcula o elemento da lista que se encontra nessa posição (assume-se que o primeiro elemento se encontra na posição 0).


Ignore os casos em que a função não se encontra definida (i.e., em que a posição fornecida não
corresponde a nenhuma posição válida da lista)."
5:
  function: reverse
  description: "Apresente uma definição recursiva da função (pré-definida) `reverse :: [a] -> [a]` que dada uma lista calcula uma lista com os elementos dessa lista pela ordem inversa."
6:
  function: take
  description: "Apresente uma definição recursiva da função (pré-definida) `take :: Int -> [a] -> [a]` que dado um inteiro n e uma lista l calcula a lista com os (no máximo) n primeiros elementos de l."
7:
  function: drop
  description: "Apresente uma definição recursiva da função (pré-definida) `drop :: Int -> [a] -> [a]` que dado um inteiro n e uma lista l calcula a lista sem os (no máximo) n primeiros elementos de l."
8:
  function: zip
  description: "Apresente uma definição recursiva da função (pré-definida) `zip :: [a] -> [b] -> [(a,b)]` que constrói uma lista de pares a partir de duas listas."
9:
  function: replicate
  description: "Apresente uma definição recursiva da função (pré-definida) `replicate :: Int -> a -> [a]` que dado um inteiro n e um elemento x constrói uma lista com n elementos, todos iguais a x."
10:
  function: intersperse
  description: "Apresente uma definição recursiva da função (pré-definida) `intersperse :: a -> [a] -> [a]` que, dado um elemento e uma lista, constrói uma lista em que o elemento fornecido é intercalado entre os elementos da lista fornecida."
11:
  function: group
  description: "Apresente uma definição recursiva da função (pré-definida) `group :: Eq a => [a] -> [[a]]` que agrupa elementos iguais e consecutivos de uma lista."
12:
  function: concat
  description: "Apresente uma definição recursiva da função (pré-definida) `concat :: [[a]] -> [a]` que concatena as listas de uma lista."
13:
  function: inits
  description: "Apresente uma definição recursiva da função (pré-definida) `inits :: [a] -> [[a]]` que calcula a lista dos prefixos de uma lista."
14:
  function: tails
  description: "Apresente uma definição recursiva da função (pré-definida) `tails :: [a] -> [[a]]` que calcula a lista dos sufixos de uma lista."
15:
  function: heads
  description: "Defina a função `heads :: [[a]] -> [a]` que recebe uma lista de listas e produz a lista com o primeiro elemento de cada lista."
16:
  function: total
  description: "Defina a função `total :: [[a]] -> Int` que recebe uma lista de listas e conta o total de elementos (de todas as listas)."
17:
  function: fun
  description: "Defina a função `fun :: [(a,b,c)] -> [(a,c)]` que recebe uma lista de triplos e produz a lista de pares com o primeiro e o terceiro elemento de cada triplo."
18:
  function: cola
  description: "Defina a função `cola :: [(String,b,c)] -> String` que recebe uma lista de triplos e concatena as strings que estão na primeira componente dos triplos."
19:
  function: idade
  description: "Defina a função `idade :: Int -> Int -> [(String,Int)] -> [String]` que recebe o ano, a idade e uma lista de pares com o nome e o ano de nascimento de cada pessoa, e devolve a listas de nomes das pessoas que nesse ano atingirão ou já ultrapassaram a idade indicada."
20:
  function: powerEnumFrom
  description: "Apresente uma definição recursiva da função `powerEnumFrom :: Int -> Int -> [Int]` que dado um valor n e um valor m constrói a lista [n^0,...,n^(m−1)]."
21:
  function: isPrime
  description: "Apresente uma definição recursiva da função `isPrime :: Int -> Bool` que dado um número inteiro maior ou igual a 2 determina se esse número é primo. Para determinar se um número n é primo, descubra se existe algum número inteiro m tal que 2 ≤ m ≤ √n e mod n m = 0. Se um tal número não existir então n é primo, e se existir então n não é primo."
22:
  function: isPrefixOf
  description: "Apresente uma definição recursiva da função (pré-definida) `isPrefixOf :: Eq a => [a] -> [a] -> Bool` que testa se uma lista é prefixo de outra."
23:
  function: isSuffixOf
  description: "Apresente uma definição recursiva da função (pré-definida) `isSuffixOf :: Eq a => [a] -> [a] -> Bool` que testa se uma lista é sufixo de outra."
24:
  function: isSubsequenceOf
  description: "Apresente uma definição recursiva da função (pré-definida) `isSubsequenceOf :: Eq a => [a] -> [a] -> Bool` que testa se os elementos de uma lista ocorrem noutra pela mesma ordem relativa."
25:
  function: elemIndices
  description: "Apresente uma definição recursiva da função (pré-definida) `elemIndices :: Eq a => a -> [a] -> [Int]` que calcula a lista de posições em que um dado elemento ocorre numa lista."
26:
  function: nub
  description: "Apresente uma definição recursiva da função (pré-definida) `nub :: Eq a => [a] -> [a]` que calcula uma lista com os mesmos elementos da recebida, sem repetições."
27:
  function: delete
  description: "Apresente uma definição recursiva da função (pré-definida) `delete :: Eq a => a -> [a] -> [a]` que retorna a lista resultante de remover (a primeira ocorrência de) um dado elemento de uma lista."
28:
  function: (\\)
  description: "Apresente uma definição recursiva da função (pré-definida) `(\\\\) :: Eq a => [a] -> [a] -> [a]` que retorna a lista resultante de remover (as primeiras ocorrências) dos elementos da segunda lista da primeira."
29:
  function: union
  description: "Apresente uma definição recursiva da função (pré-definida) `union :: Eq a => [a] -> [a] -> [a]` que retorna a lista resultante de acrescentar à primeira lista os elementos da segunda que não ocorrem na primeira."
30:
  function: intersect
  description: "Apresente uma definição recursiva da função (pré-definida) `intersect :: Eq a => [a] -> [a] -> [a]` que retorna a lista resultante de remover da primeira lista os elementos que não pertencem à segunda."
31:
  function: insert
  description: "Apresente uma definição recursiva da função (pré-definida) `insert :: Ord a => a -> [a] -> [a]` que dado um elemento e uma lista ordenada retorna a lista resultante de inserir ordenadamente esse elemento na lista."
32:
  function: unwords
  description: "Apresente uma definição recursiva da função (pré-definida) `unwords :: [String] -> String` que junta todas as strings da lista numa só, separando-as por um espaço."
33:
  function: unlines
  description: "Apresente uma definição recursiva da função (pré-definida) `unlines :: [String] -> String` que junta todas as strings da lista numa só, separando-as pelo caracter ’\\n’."
34:
  function: pMaior
  description: "Apresente uma definição recursiva da função `pMaior :: Ord a => [a] -> Int` que dada uma lista não vazia, retorna a posição onde se encontra o maior elemento da lista. As posições da lista começam em 0, i.e., a função deverá retornar 0 se o primeiro elemento da lista for o maior."
35:
  function: lookup
  description: "Apresente uma definição recursiva da função (pré-definida) `lookup :: Eq a => a -> [(a,b)] -> Maybe b` que retorna uma lista construída a partir de elementos de uma lista (o segundo argumento) atendendo a uma condição dada pelo primeiro argumento."
36:
  function: preCrescente
  description: "Defina a função `preCrescente :: Ord a => [a] -> [a]` que calcula o maior prefixo crescente de uma lista."
37:
  function: iSort
  description: "Apresente uma definição recursiva da função `iSort :: Ord a => [a] -> [a]` que calcula o resultado de ordenar uma lista. Assuma, se precisar, que existe definida a função `insert :: Ord a => a -> [a] -> [a]` que dado um elemento e uma lista ordenada retorna a lista resultante de inserir ordenadamente esse elemento na lista."
38:
  function: menor
  description: "Apresente uma definição recursiva da função `menor :: String -> String -> Bool` que dadas duas strings, retorna True se e só se a primeira for menor do que a segunda, segundo a ordem lexicográfica (i.e., do dicionário)"
39:
  function: elemMSet
  description: "Considere que se usa o tipo `[(a,Int)]` para representar multi-conjuntos de elementos de a. Considere ainda que nestas listas não há pares cuja primeira componente coincida, nem cuja segunda componente seja menor ou igual a zero.

Defina a função `elemMSet :: Eq a => a -> [(a,Int)] -> Bool` que testa se um elemento pertence a um multi-conjunto."
40:
  function: converteMSet
  description: "Considere que se usa o tipo `[(a,Int)]` para representar multi-conjuntos de elementos de a. Considere ainda que nestas listas não há pares cuja primeira componente coincida, nem cuja segunda componente seja menor ou igual a zero.

Defina a função `converteMSet :: [(a,Int)] -> [a]` que converte um multi-conjuto na lista dos seus elementos."
41:
  function: insereMSet
  description: "Considere que se usa o tipo `[(a,Int)]` para representar multi-conjuntos de elementos de a. Considere ainda que nestas listas não há pares cuja primeira componente coincida, nem cuja segunda componente seja menor ou igual a zero.

Defina a função `insereMSet :: Eq a => a -> [(a,Int)] -> [(a,Int)]` que acrescenta um elemento a um multi-conjunto."
42:
  function: removeMSet
  description: "Considere que se usa o tipo `[(a,Int)]` para representar multi-conjuntos de elementos de a. Considere ainda que nestas listas não há pares cuja primeira componente coincida, nem cuja segunda componente seja menor ou igual a zero.

Defina a função removeMSet :: Eq a => a -> [(a,Int)] -> [(a,Int)] que remove um elemento a um multi-conjunto. Se o elemento não existir, deve ser retornado o multi-conjunto recebido."
43:
  function: constroiMSet
  description: "Considere que se usa o tipo `[(a,Int)]` para representar multi-conjuntos de elementos de a. Considere ainda que nestas listas não há pares cuja primeira componente coincida, nem cuja segunda componente seja menor ou igual a zero.

Defina a função `constroiMSet :: Ord a => [a] -> [(a,Int)]` dada uma lista ordenada por ordem crescente, calcula o multi-conjunto dos seus elementos."
44:
  function: partitionEithers
  description: "Apresente uma definição recursiva da função pré-definida `partitionEithers :: [Either a b] -> ([a],[b])` que divide uma lista de Either s em duas listas."
45:
  function: catMaybes
  description: "Apresente uma definição recursiva da função pré-definida `catMaybes :: [Maybe a] -> [a]` que coleciona os elementos do tipo a de uma lista."
46:
  function: caminho
  description: "Considere o seguinte tipo para representar movimentos de um robot.

`data Movimento = Norte | Sul | Este | Oeste`
      `deriving Show`

Defina a função `caminho :: (Int,Int) -> (Int,Int) -> [Movimento]` que, dadas as posições inicial e final (coordenadas) do robot, produz uma lista de movimentos suficientes para que o robot passe de uma posição para a outra."
47:
  function: hasLoops
  description: "Considere o seguinte tipo para representar movimentos de um robot.

`data Movimento = Norte | Sul | Este | Oeste`
      `deriving Show`

Defina a função `hasLoops :: (Int,Int) -> [Movimento] -> Bool` que dada uma posição inicial e uma lista de movimentos (correspondentes a um percurso) verifica se o robot alguma vez volta a passar pela posição inicial ao longo do percurso correspondente. Pode usar a função `posicao` definida acima."
48:
  function: contaQuadrados
  description: "Considere os seguintes tipos para representar pontos e retângulos, respectivamente. Assuma que os retângulos têm os lados paralelos aos eixos e são representados apenas por dois dos pontos mais afastados.

`type Ponto = (Float,Float)`
`data Rectangulo = Rect Ponto Ponto`

Defina a função `contaQuadrados :: [Rectangulo] -> Int` que, dada uma lista com retângulos,
conta quantos deles são quadrados."
49:
  function: areaTotal
  description: "Considere os seguintes tipos para representar pontos e retângulos, respectivamente. Assuma que os retângulos têm os lados paralelos aos eixos e são representados apenas por dois dos pontos mais afastados.

`type Ponto = (Float,Float)`
`data Rectangulo = Rect Ponto Ponto`

Defina a função `areaTotal :: [Rectangulo] -> Float` que, dada uma lista com retângulos, determina a área total que eles ocupam."
50:
  function: naoReparar
  description: "Considere o seguinte tipo para representar o estado de um equipamento.

`data Equipamento = Bom | Razoavel | Avariado`
        `deriving Show`

Defina a função `naoReparar :: [Equipamento] -> Int` que determina a quantidade de equipamentos que não estão avariados"